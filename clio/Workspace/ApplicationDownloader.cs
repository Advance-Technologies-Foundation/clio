using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Clio.Common;
using Clio.Common.CsProjManager;
using Clio.Package;
using Clio.WebApplication;

namespace Clio.Workspaces
{

	#region Interface: ILibrariesDownloader

	public interface IApplicationDownloader
	{

		#region Methods: Public

		void Download(IEnumerable<string> packagesNames = null); 
		void DownloadAutogeneratedPackages(IEnumerable<string> packagesNames);
		void DownloadAutogeneratedPackages(string packageName);

		#endregion

	}

	#endregion

	#region Class: LibrariesDownloader

	public class ApplicationDownloader : IApplicationDownloader
	{

		#region Constants: Private

		private const string SchemasFolderName = "Schemas";
		private const string AutogeneratedFolderName = "Autogenerated";

		#endregion

		#region Fields: Private

		private readonly IDownloader _downloader;
		private readonly IServiceUrlBuilder _serviceUrlBuilder;
		private readonly IWorkspacePathBuilder _workspacePathBuilder;
		private readonly IWorkingDirectoriesProvider _workingDirectoriesProvider;
		private readonly IFileSystem _fileSystem;
		private readonly ICsprojFile _csprojFile;
		private readonly IClioGateway _clioGateway;
		private readonly ILogger _logger;
		private readonly IApplicationPackageListProvider _applicationPackageListProvider;

		#endregion

		#region Constructors: Public

		public ApplicationDownloader(IDownloader downloader, IServiceUrlBuilder serviceUrlBuilder,
				IWorkspacePathBuilder workspacePathBuilder, IWorkingDirectoriesProvider workingDirectoriesProvider,
				IFileSystem fileSystem, ICsprojFile csprojFile, IClioGateway clioGateway, ILogger logger) {
			downloader.CheckArgumentNull(nameof(downloader));
			serviceUrlBuilder.CheckArgumentNull(nameof(serviceUrlBuilder));
			workspacePathBuilder.CheckArgumentNull(nameof(workspacePathBuilder));
			workingDirectoriesProvider.CheckArgumentNull(nameof(workingDirectoriesProvider));
			fileSystem.CheckArgumentNull(nameof(fileSystem));
			_downloader = downloader;
			_serviceUrlBuilder = serviceUrlBuilder;
			_workspacePathBuilder = workspacePathBuilder;
			_workingDirectoriesProvider = workingDirectoriesProvider;
			_fileSystem = fileSystem;
			_csprojFile = csprojFile;
			_clioGateway = clioGateway;
			_logger = logger;
		}

		#endregion

		#region Properties: Private

		private string ApplicationFolderPath => _workspacePathBuilder.ApplicationFolderPath;
		private string CoreBinFolderPath  => _workspacePathBuilder.CoreBinFolderPath;
		private string LibFolderPath  => _workspacePathBuilder.LibFolderPath;
		private string ConfigurationBinFolderPath  => _workspacePathBuilder.ConfigurationBinFolderPath;
		private bool IsWorkspace => _workspacePathBuilder.IsWorkspace;
		private string AutogeneratedPkgUrl => GetUrl($"/rest/CreatioApiGateway/GetAutogeneratedFolder");
		private DownloadInfo[] DownloadInfos => GetDownloadInfos(); 

		#endregion

		#region Methods: Private

		private DownloadInfo[] GetDownloadInfos() {
			return new [] {
					new DownloadInfo(GetUrl("/rest/CreatioApiGateway/GetCoreBinFolder"),
						"CoreBin", CoreBinFolderPath),
					new DownloadInfo(GetUrl("/rest/CreatioApiGateway/GetConfigurationLibFolder"),
						"Lib", LibFolderPath),
					new DownloadInfo(GetUrl("/rest/CreatioApiGateway/GetConfigurationBinFolder"),
						"ConfigurationBin", ConfigurationBinFolderPath),
				};
		}

		private IEnumerable<DownloadInfo> GetAutogeneratedPackagesDownloadInfos(IEnumerable<string> packagesNames) =>
			packagesNames.Select(packageName => new DownloadInfo(AutogeneratedPkgUrl, 
				$"Autogenerated.{packageName}", BuildAutogeneratedPackagePath(packageName), 
				GetPackageRequestData(packageName))); 

		private string GetUrl(string endpoint) => _serviceUrlBuilder.Build(endpoint);
		private string GetUrl(ServiceUrlBuilder.KnownRoute url) => _serviceUrlBuilder.Build(url);

		private string BuildAutogeneratedPackagePath(string packageName) =>
			Path.Combine(BuildPackagePath(packageName), AutogeneratedFolderName);

		private string BuildSchemasPackagePath(string packageName) =>
			Path.Combine(BuildPackagePath(packageName), SchemasFolderName);

		
		private string BuildPackagePath(string packageName) => IsWorkspace
			? _workspacePathBuilder.BuildPackagePath(packageName)
			: Path.Combine(_workingDirectoriesProvider.CurrentDirectory, packageName);

		private string GetSafePackageName(string packageName) => packageName
			.Replace(" ", string.Empty)
			.Replace(",", "\",\"");

		private string GetPackageRequestData(string packageName) {
			string safePackageName = GetSafePackageName(packageName);
			return $"\"{safePackageName}\"";;
		}

		private void DeleteSourceSchemasFromAutogenerated(IEnumerable<string> packagesNames) {
			foreach (string packageName in packagesNames) {
				string schemasPackagePath = BuildSchemasPackagePath(packageName);
				FileInfo[] filesInfos = _fileSystem
					.GetFilesInfos(schemasPackagePath, "*.cs", SearchOption.AllDirectories);
				foreach (var fileInfo in filesInfos) {
					string autogeneratedFilePath = Path.Combine(BuildAutogeneratedPackagePath(packageName), "Src",
						$"{_fileSystem.GetFileNameWithoutExtension(fileInfo)}.{packageName}.cs");
					_fileSystem.DeleteFileIfExists(autogeneratedFilePath);
				}
			}
		}

		private void CreateMarkerPackagesFolder() =>
			_fileSystem.CreateDirectory(Path.Combine(ApplicationFolderPath, "packages"));

		#endregion

		#region Methods: Public

		public void Download(IEnumerable<string> packagesNames = null) {
			packagesNames ??= Enumerable.Empty<string>();
			
			const string minClioGateVersionForDownload = "2.0.0.0";
			if(_clioGateway.IsCompatibleWith(minClioGateVersionForDownload)) {
				IEnumerable<string> enumerablePackagesNames = packagesNames as string[] ?? packagesNames.ToArray();
				IEnumerable<DownloadInfo> autogeneratedPackagesDownloadInfos = 
					GetAutogeneratedPackagesDownloadInfos(enumerablePackagesNames);
				IEnumerable<DownloadInfo> allDownloadInfos = DownloadInfos.Union(autogeneratedPackagesDownloadInfos);
				_downloader.Download(allDownloadInfos);
				
				const string minClioGateVersion = "2.0.0.29";
				if(_clioGateway.IsCompatibleWith(minClioGateVersion)) {
					IEnumerable<DownloadInfo> files = GetDownloadInfoFromCsProj(enumerablePackagesNames) ;
					IEnumerable<DownloadInfo> downloadInfos = files as DownloadInfo[] ?? files.ToArray();
					if(downloadInfos.Any()) {
						_downloader.DownloadPackageDll(downloadInfos);
					}
				}else {
					_logger.WriteWarning($"Downloading of referenced package dlls requires cliogate version {minClioGateVersion} or higher.");
				}
				
				CreateMarkerPackagesFolder();
				DeleteSourceSchemasFromAutogenerated(enumerablePackagesNames);
			}
			else {
				_logger.WriteWarning($"Downloading of cor libraries requires cliogate version {minClioGateVersionForDownload} or higher.");
			}
		}
		
		public IEnumerable<DownloadInfo> GetDownloadInfoFromCsProj(IEnumerable<string> packagesNames){
			IEnumerable<string> enumerablePackagesNames = packagesNames as string[] ?? packagesNames.ToArray();
			if(!enumerablePackagesNames.Any()) {
				return Array.Empty<DownloadInfo>();
			}
			List<DownloadInfo> downloadInfos = new();
			List<Reference> packageRefsFromAllPackages = new();
			foreach (string packagesName in enumerablePackagesNames) {
				IInitializedCsprojFile init = _csprojFile.Initialize(packagesName);
				IEnumerable<Reference> refs = init.GetPackageReferences();
				IEnumerable<Reference> collection = refs.ToList();
				packageRefsFromAllPackages.AddRange(collection);
			}
			IEnumerable<Reference> distinctRefs = packageRefsFromAllPackages.DistinctBy(i => i.PackageName);
			
			foreach (Reference @ref in distinctRefs) {
				string dllName = @ref.HintPath.Split('/').Last();
				var payloadObj = new {
					packageName = @ref.PackageName,
					dllName
				};
				string packagesFolderPath = ApplicationFolderPath switch {
					_ when ApplicationFolderPath.Contains("net-core") => Path.Combine(ApplicationFolderPath, "packages", @ref.PackageName, "Files", "Bin", "netstandard", dllName),
					_ when ApplicationFolderPath.Contains("net-framework") => Path.Combine(ApplicationFolderPath, "packages", @ref.PackageName, "Files", "Bin", dllName),
					_ => throw new ArgumentOutOfRangeException(nameof(ApplicationFolderPath),ApplicationFolderPath, 
						"ApplicationFolderPath is not net-core or net-framework")
				} ;
				
				string requestData = System.Text.Json.JsonSerializer.Serialize(payloadObj);
				DownloadInfo di = new (
					GetUrl(ServiceUrlBuilder.KnownRoute.DownloadPackageDllFile),
					dllName, packagesFolderPath, requestData);
				downloadInfos.Add(di);
			}
			return downloadInfos;
		}

		public void DownloadAutogeneratedPackages(IEnumerable<string> packagesNames) {
			IEnumerable<DownloadInfo> autogeneratedPackagesDownloadInfos = 
				GetAutogeneratedPackagesDownloadInfos(packagesNames);
			_downloader.Download(autogeneratedPackagesDownloadInfos);
			DeleteSourceSchemasFromAutogenerated(packagesNames);
		}

		public void DownloadAutogeneratedPackages(string packageName) =>
			DownloadAutogeneratedPackages(new[] { packageName });

		#endregion

	}

	#endregion

}