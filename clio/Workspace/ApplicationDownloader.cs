using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Clio.Common;
using Clio.Common.CsProjManager;
using Clio.Package;
using Clio.WebApplication;

namespace Clio.Workspaces;

#region Interface: ILibrariesDownloader

public interface IApplicationDownloader
{
    #region Methods: Public

    void Download(IEnumerable<string> packagesNames = null);
    void DownloadAutogeneratedPackages(IEnumerable<string> packagesNames);
    void DownloadAutogeneratedPackages(string packageName);

    #endregion
}

#endregion

#region Class: LibrariesDownloader

public class ApplicationDownloader : IApplicationDownloader
{
    #region Constants: Private

    private const string SchemasFolderName = "Schemas";
    private const string AutogeneratedFolderName = "Autogenerated";

    #endregion

    #region Fields: Private

    private readonly IDownloader _downloader;
    private readonly IServiceUrlBuilder _serviceUrlBuilder;
    private readonly IWorkspacePathBuilder _workspacePathBuilder;
    private readonly IWorkingDirectoriesProvider _workingDirectoriesProvider;
    private readonly IFileSystem _fileSystem;
    private readonly ICsprojFile _csprojFile;
    private readonly IClioGateway _clioGateway;
    private readonly ILogger _logger;
    private readonly IApplicationPackageListProvider _applicationPackageListProvider;

    #endregion

    #region Constructors: Public

    public ApplicationDownloader(IDownloader downloader, IServiceUrlBuilder serviceUrlBuilder,
        IWorkspacePathBuilder workspacePathBuilder, IWorkingDirectoriesProvider workingDirectoriesProvider,
        IFileSystem fileSystem, ICsprojFile csprojFile, IClioGateway clioGateway, ILogger logger)
    {
        downloader.CheckArgumentNull(nameof(downloader));
        serviceUrlBuilder.CheckArgumentNull(nameof(serviceUrlBuilder));
        workspacePathBuilder.CheckArgumentNull(nameof(workspacePathBuilder));
        workingDirectoriesProvider.CheckArgumentNull(nameof(workingDirectoriesProvider));
        fileSystem.CheckArgumentNull(nameof(fileSystem));
        _downloader = downloader;
        _serviceUrlBuilder = serviceUrlBuilder;
        _workspacePathBuilder = workspacePathBuilder;
        _workingDirectoriesProvider = workingDirectoriesProvider;
        _fileSystem = fileSystem;
        _csprojFile = csprojFile;
        _clioGateway = clioGateway;
        _logger = logger;
    }

    #endregion

    #region Properties: Private

    private string ApplicationFolderPath => _workspacePathBuilder.ApplicationFolderPath;
    private string CoreBinFolderPath => _workspacePathBuilder.CoreBinFolderPath;
    private string LibFolderPath => _workspacePathBuilder.LibFolderPath;
    private string ConfigurationBinFolderPath => _workspacePathBuilder.ConfigurationBinFolderPath;
    private bool IsWorkspace => _workspacePathBuilder.IsWorkspace;
    private string AutogeneratedPkgUrl => GetUrl($"/rest/CreatioApiGateway/GetAutogeneratedFolder");
    private DownloadInfo[] DownloadInfos => GetDownloadInfos();

    #endregion

    #region Methods: Private

    private DownloadInfo[] GetDownloadInfos() =>
        new[]
        {
            new DownloadInfo(GetUrl("/rest/CreatioApiGateway/GetCoreBinFolder"),
                "CoreBin", CoreBinFolderPath),
            new DownloadInfo(GetUrl("/rest/CreatioApiGateway/GetConfigurationLibFolder"),
                "Lib", LibFolderPath),
            new DownloadInfo(GetUrl("/rest/CreatioApiGateway/GetConfigurationBinFolder"),
                "ConfigurationBin", ConfigurationBinFolderPath)
        };

    private IEnumerable<DownloadInfo> GetAutogeneratedPackagesDownloadInfos(IEnumerable<string> packagesNames) =>
        packagesNames.Select(packageName => new DownloadInfo(AutogeneratedPkgUrl,
            $"Autogenerated.{packageName}", BuildAutogeneratedPackagePath(packageName),
            GetPackageRequestData(packageName)));

    private string GetUrl(string endpoint) => _serviceUrlBuilder.Build(endpoint);
    private string GetUrl(ServiceUrlBuilder.KnownRoute url) => _serviceUrlBuilder.Build(url);

    private string BuildAutogeneratedPackagePath(string packageName) =>
        Path.Combine(BuildPackagePath(packageName), AutogeneratedFolderName);

    private string BuildSchemasPackagePath(string packageName) =>
        Path.Combine(BuildPackagePath(packageName), SchemasFolderName);


    private string BuildPackagePath(string packageName) => IsWorkspace
        ? _workspacePathBuilder.BuildPackagePath(packageName)
        : Path.Combine(_workingDirectoriesProvider.CurrentDirectory, packageName);

    private string GetSafePackageName(string packageName) => packageName
        .Replace(" ", string.Empty)
        .Replace(",", "\",\"");

    private string GetPackageRequestData(string packageName)
    {
        string safePackageName = GetSafePackageName(packageName);
        return $"\"{safePackageName}\"";
        ;
    }

    private void DeleteSourceSchemasFromAutogenerated(IEnumerable<string> packagesNames)
    {
        foreach (string packageName in packagesNames)
        {
            string schemasPackagePath = BuildSchemasPackagePath(packageName);
            FileInfo[] filesInfos = _fileSystem
                .GetFilesInfos(schemasPackagePath, "*.cs", SearchOption.AllDirectories);
            foreach (FileInfo fileInfo in filesInfos)
            {
                string autogeneratedFilePath = Path.Combine(BuildAutogeneratedPackagePath(packageName), "Src",
                    $"{_fileSystem.GetFileNameWithoutExtension(fileInfo)}.{packageName}.cs");
                _fileSystem.DeleteFileIfExists(autogeneratedFilePath);
            }
        }
    }

    private void CreateMarkerPackagesFolder() =>
        _fileSystem.CreateDirectory(Path.Combine(ApplicationFolderPath, "packages"));

    #endregion

    #region Methods: Public

    public void Download(IEnumerable<string> packagesNames = null)
    {
        packagesNames ??= Enumerable.Empty<string>();

        const string minClioGateVersionForDownload = "2.0.0.0";
        if (_clioGateway.IsCompatibleWith(minClioGateVersionForDownload))
        {
            IEnumerable<string> enumerablePackagesNames = packagesNames as string[] ?? packagesNames.ToArray();
            IEnumerable<DownloadInfo> autogeneratedPackagesDownloadInfos =
                GetAutogeneratedPackagesDownloadInfos(enumerablePackagesNames);
            IEnumerable<DownloadInfo> allDownloadInfos = DownloadInfos.Union(autogeneratedPackagesDownloadInfos);
            _downloader.Download(allDownloadInfos);

            const string minClioGateVersion = "2.0.0.29";
            if (_clioGateway.IsCompatibleWith(minClioGateVersion))
            {
                IEnumerable<DownloadInfo> files = GetDownloadInfoFromCsProj(enumerablePackagesNames);
                IEnumerable<DownloadInfo> downloadInfos = files as DownloadInfo[] ?? files.ToArray();
                if (downloadInfos.Any())
                {
                    _downloader.DownloadPackageDll(downloadInfos);
                }
            }
            else
            {
                _logger.WriteWarning(
                    $"Downloading of referenced package dlls requires cliogate version {minClioGateVersion} or higher.");
            }

            CreateMarkerPackagesFolder();
            DeleteSourceSchemasFromAutogenerated(enumerablePackagesNames);
        }
        else
        {
            _logger.WriteWarning(
                $"Downloading of cor libraries requires cliogate version {minClioGateVersionForDownload} or higher.");
        }
    }

    public IEnumerable<DownloadInfo> GetDownloadInfoFromCsProj(IEnumerable<string> packagesNames)
    {
        IEnumerable<string> enumerablePackagesNames = packagesNames as string[] ?? packagesNames.ToArray();
        if (!enumerablePackagesNames.Any())
        {
            return Array.Empty<DownloadInfo>();
        }

        List<DownloadInfo> downloadInfos = new();
        List<Reference> packageRefsFromAllPackages = new();
        foreach (string packagesName in enumerablePackagesNames)
        {
            IInitializedCsprojFile init = _csprojFile.Initialize(packagesName);
            IEnumerable<Reference> refs = init.GetPackageReferences();
            IEnumerable<Reference> collection = refs.ToList();
            packageRefsFromAllPackages.AddRange(collection);
        }

        IEnumerable<Reference> distinctRefs = packageRefsFromAllPackages.DistinctBy(i => i.PackageName);

        foreach (Reference @ref in distinctRefs)
        {
            string dllName = @ref.HintPath.Split('/').Last();
            var payloadObj = new { packageName = @ref.PackageName, dllName };
            string packagesFolderPath = ApplicationFolderPath switch
            {
                _ when ApplicationFolderPath.Contains("net-core") => Path.Combine(ApplicationFolderPath, "packages",
                    @ref.PackageName, "Files", "Bin", "netstandard", dllName),
                _ when ApplicationFolderPath.Contains("net-framework") => Path.Combine(ApplicationFolderPath,
                    "packages", @ref.PackageName, "Files", "Bin", dllName),
                _ => throw new ArgumentOutOfRangeException(nameof(ApplicationFolderPath), ApplicationFolderPath,
                    "ApplicationFolderPath is not net-core or net-framework")
            };

            string requestData = System.Text.Json.JsonSerializer.Serialize(payloadObj);
            DownloadInfo di = new(
                GetUrl(ServiceUrlBuilder.KnownRoute.DownloadPackageDllFile),
                dllName, packagesFolderPath, requestData);
            downloadInfos.Add(di);
        }

        return downloadInfos;
    }

    public void DownloadAutogeneratedPackages(IEnumerable<string> packagesNames)
    {
        IEnumerable<DownloadInfo> autogeneratedPackagesDownloadInfos =
            GetAutogeneratedPackagesDownloadInfos(packagesNames);
        _downloader.Download(autogeneratedPackagesDownloadInfos);
        DeleteSourceSchemasFromAutogenerated(packagesNames);
    }

    public void DownloadAutogeneratedPackages(string packageName) =>
        DownloadAutogeneratedPackages(new[] { packageName });

    #endregion
}

#endregion
